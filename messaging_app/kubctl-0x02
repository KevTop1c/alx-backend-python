#!/bin/bash

# kubctl-0x02 - Blue-Green Deployment Script
set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions
log_header() {
    echo -e "\n${CYAN}================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}================================${NC}\n"
}
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Configuration
NAMESPACE="default"
APP_NAME="django-messaging"
BLUE_DEPLOYMENT="django-messaging-app-blue"
GREEN_DEPLOYMENT="django-messaging-app-green"
BLUE_DEPLOYMENT_FILE="blue_deployment.yaml"
GREEN_DEPLOYMENT_FILE="messaging_app/green_deployment.yaml"
SERVICE_FILE="kubeservice.yaml"
MAIN_SERVICE="django-messaging-service"
BLUE_SERVICE="django-messaging-service-blue"
GREEN_SERVICE="django-messaging-service-green"
HEALTH_CHECK_TIMEOUT=120
HEALTH_CHECK_PATH="/admin/"
LOG_LINES=50

# Function to check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed"
        exit 1
    fi
    
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
}

# Function to get current active version
get_active_version() {
    local version=$(kubectl get service $MAIN_SERVICE -n $NAMESPACE -o jsonpath='{.spec.selector.version}' 2>/dev/null || echo "none")
    echo "$version"
}

# Function to check if deployment exists
deployment_exists() {
    local deployment=$1
    kubectl get deployment $deployment -n $NAMESPACE &> /dev/null
    return $?
}

# Function to check deployment health
check_deployment_health() {
    local deployment=$1
    local timeout=$2
    
    log_info "Checking health of $deployment..."
    
    # Wait for deployment to be ready
    if kubectl rollout status deployment/$deployment -n $NAMESPACE --timeout=${timeout}s &> /dev/null; then
        log_success "$deployment is healthy and ready"
        return 0
    else
        log_error "$deployment failed health check"
        return 1
    fi
}

# Function to get pod names for a deployment
get_pods() {
    local version=$1
    kubectl get pods -n $NAMESPACE -l app=$APP_NAME,version=$version -o jsonpath='{.items[*].metadata.name}'
}

# Function to check pod logs for errors
check_logs_for_errors() {
    local deployment=$1
    local version=$2
    
    log_info "Checking logs for $deployment..."
    
    local pods=$(get_pods $version)
    
    if [ -z "$pods" ]; then
        log_warning "No pods found for version: $version"
        return 1
    fi
    
    local error_count=0
    
    for pod in $pods; do
        echo -e "\n${CYAN}--- Logs for pod: $pod ---${NC}"
        
        # Get recent logs
        local logs=$(kubectl logs $pod -n $NAMESPACE --tail=$LOG_LINES 2>&1)
        
        # Display logs
        echo "$logs"
        
        # Check for critical errors (excluding health check 404s)
        local critical_errors=$(echo "$logs" | grep -iE "error|exception|failed|traceback" | grep -v "Not Found: /" | wc -l)
        
        if [ $critical_errors -gt 0 ]; then
            log_warning "Found $critical_errors potential error(s) in pod $pod"
            error_count=$((error_count + critical_errors))
        fi
    done
    
    echo ""
    
    if [ $error_count -gt 0 ]; then
        log_warning "Total errors found across all pods: $error_count"
        return 1
    else
        log_success "No critical errors found in logs"
        return 0
    fi
}

# Function to deploy blue version
deploy_blue() {
    log_header "Deploying Blue Version (Current Stable)"

    if [ ! -f "$BLUE_DEPLOYMENT_FILE" ]; then
        log_error "$BLUE_DEPLOYMENT_FILE not found!"
        exit 1
    fi
    
    log_info "Deploying Blue version..."
    if ! kubectl apply -f "$BLUE_DEPLOYMENT_FILE"; then
        log_error "Failed to apply Blue deployment manifest"
        exit 1
    fi
    
    log_info "Waiting for blue pods to be ready..."
    if check_deployment_health "$BLUE_DEPLOYMENT" "$HEALTH_CHECK_TIMEOUT"; then
        log_success "Blue deployment is ready!"
    else
        log_error "Blue deployment failed to become ready"
        exit 1
    fi
    
    # Check logs
    check_logs_for_errors "$BLUE_DEPLOYMENT" "blue" || log_warning "Blue deployment has some warnings in logs"
}

# Function to deploy green version
deploy_green() {
    log_header "Deploying Green Version (New Version)"

    if [ ! -f "$GREEN_DEPLOYMENT_FILE" ]; then
        log_error "$GREEN_DEPLOYMENT_FILE not found!"
        exit 1
    fi

    log_info "Deploying Green version..."
    if ! kubectl apply -f "$GREEN_DEPLOYMENT_FILE"; then
        log_error "Failed to apply Green deployment manifest"
        exit 1
    fi
    
    log_info "Waiting for green pods to be ready..."
    if check_deployment_health "$GREEN_DEPLOYMENT" "$HEALTH_CHECK_TIMEOUT"; then
        log_success "Green deployment is ready!"
    else
        log_error "Green deployment failed to become ready"
        log_error "Checking logs for errors..."
        check_logs_for_errors "$GREEN_DEPLOYMENT" "green"
        exit 1
    fi
    
    # Check logs for errors
    if ! check_logs_for_errors $GREEN_DEPLOYMENT "green"; then
        log_warning "Green deployment has errors in logs"
        read -p "Do you want to continue with the switch? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Aborting deployment"
            exit 1
        fi
    fi
}

# Function to deploy services
deploy_services() {
    log_header "Step 2: Deploying Services"

    if [ ! -f "$SERVICE_FILE" ]; then
        log_error "$SERVICE_FILE not found!"
        exit 1
    fi

    log_info "Deploying services..."
    if ! kubectl apply -f "$SERVICE_FILE"; then
        log_error "Failed to apply Service deployment manifest"
        exit 1
    fi
    
    sleep 5
    log_success "Services deployed"
}

# Function to test version via service
test_version() {
    local service=$1
    local version_name=$2
    
    log_info "Testing $version_name version via $service..."
    
    # Port forward to test
    kubectl port-forward service/$service 8888:80 -n $NAMESPACE &
    local pf_pid=$!
    sleep 3
    
    # Test endpoint
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8888$HEALTH_CHECK_PATH 2>/dev/null || echo "000")
    
    # Kill port forward
    kill $pf_pid 2>/dev/null || true
    wait $pf_pid 2>/dev/null || true
    
    if [[ "$http_code" =~ ^(200|301|302)$ ]]; then
        log_success "$version_name version is responding (HTTP $http_code)"
        return 0
    else
        log_error "$version_name version is not responding properly (HTTP $http_code)"
        return 1
    fi
}

# Function to check deployment status
check_deployment_status() {
    log_header "Deployment Status"
    
    echo -e "${CYAN}Active Version:${NC} $(get_active_version)"
    echo ""
    
    echo -e "${CYAN}Services:${NC}"
    kubectl get svc -n $NAMESPACE -l app=$APP_NAME
    echo ""
    
    echo -e "${CYAN}Deployments:${NC}"
    kubectl get deployments -n $NAMESPACE -l app=$APP_NAME
    echo ""
    
    echo -e "${CYAN}Pods:${NC}"
    kubectl get pods -n $NAMESPACE -l app=$APP_NAME -o wide
    echo ""
    
    echo -e "${CYAN}Blue Pods:${NC}"
    local blue_pods=$(get_pods "blue")
    if [ -n "$blue_pods" ]; then
        for pod in $blue_pods; do
            echo "  - $pod: $(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.phase}')"
        done
    else
        echo "  No blue pods running"
    fi
    echo ""
    
    echo -e "${CYAN}Green Pods:${NC}"
    local green_pods=$(get_pods "green")
    if [ -n "$green_pods" ]; then
        for pod in $green_pods; do
            echo "  - $pod: $(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.phase}')"
        done
    else
        echo "  No green pods running"
    fi
}

# Function to switch traffic
switch_traffic() {
    local target_version=$1
    
    log_header "Step 3: Switching Traffic to $target_version Version"
    
    log_info "Current active version: $(get_active_version)"
    
    # Confirm switch
    read -p "Switch traffic to $target_version version? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Traffic switch cancelled"
        return 1
    fi
    
    log_info "Updating service selector to point to $target_version..."
    kubectl patch service $MAIN_SERVICE -n $NAMESPACE -p "{\"spec\":{\"selector\":{\"version\":\"$target_version\"}}}"
    
    sleep 2
    
    log_success "Traffic switched to $target_version version!"
    log_info "New active version: $(get_active_version)"
}

# Function to monitor application health
monitor_health() {
    log_info "Monitoring application health for 30 seconds..."
    
    for i in {1..6}; do
        log_info "Health check $i/6..."
        
        # Check all pods are running
        RUNNING_PODS=$(kubectl get pods -l app=django-messaging --no-headers | grep -c "Running")
        TOTAL_PODS=$(kubectl get pods -l app=django-messaging --no-headers | wc -l)
        
        log_info "Pods status: $RUNNING_PODS/$TOTAL_PODS running"
        
        # Quick curl test to main service
        kubectl port-forward service/$MAIN_SERVICE 8000:8000 > /dev/null 2>&1 &
        PF_PID=$!
        sleep 2
        
        if curl -s http://localhost:8000 > /dev/null 2>&1; then
            log_success "Application is responding"
        else
            log_warning "Application not responding on attempt $i"
        fi
        
        kill $PF_PID 2>/dev/null || true
        sleep 5
    done
}

# Function to rollback to previous version
rollback() {
    local current=$(get_active_version)
    local target=""
    
    if [ "$current" == "green" ]; then
        target="blue"
    elif [ "$current" == "blue" ]; then
        target="green"
    else
        log_error "Cannot determine rollback target"
        exit 1
    fi
    
    log_header "Rolling Back from $current to $target"
    
    log_warning "This will switch traffic back to $target version"
    read -p "Continue with rollback? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Rollback cancelled"
        return
    fi
    
    kubectl patch service $MAIN_SERVICE -n $NAMESPACE -p "{\"spec\":{\"selector\":{\"version\":\"$target\"}}}"
    
    log_success "Rolled back to $target version!"
}

# Function to cleanup old version
cleanup() {
    local version=$1
    
    log_header "Cleaning Up $version Version"
    
    log_warning "This will delete the $version deployment"
    read -p "Continue with cleanup? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Cleanup cancelled"
        return
    fi
    
    if [ "$version" == "blue" ]; then
        kubectl delete deployment $BLUE_DEPLOYMENT -n $NAMESPACE
        log_success "Blue deployment cleaned up"
    elif [ "$version" == "green" ]; then
        kubectl delete deployment $GREEN_DEPLOYMENT -n $NAMESPACE
        log_success "Green deployment cleaned up"
    fi
}

show_usage() {
    cat << EOF
${CYAN}Blue-Green Deployment Script${NC}

Usage: $0 [COMMAND]

Commands:
    deploy              Deploy both blue and green versions
    deploy-blue         Deploy only blue version
    deploy-green        Deploy only green version
    switch-to-blue      Switch traffic to blue version
    switch-to-green     Switch traffic to green version
    test                Test both versions
    test-blue           Test blue version
    test-green          Test green version
    status              Show deployment status
    logs-blue           Show logs for blue version
    logs-green          Show logs for green version
    rollback            Rollback to previous version
    monitor-health      Monitor application health
    cleanup-blue        Remove blue deployment
    cleanup-green       Remove green deployment
    help                Show this help message

Examples:
    $0 deploy           # Deploy both versions
    $0 switch-to-green  # Switch traffic to green version
    $0 status           # Show current status
    $0 rollback         # Rollback to previous version

EOF
}

# Main deployment function
main() {
    local command=${1:-deploy}
    
    case $command in
        deploy)
            log_header "Blue-Green Deployment Script"
            check_prerequisites
            log_info "Starting Blue-Green Deployment..."
            deploy_blue
            deploy_services
            deploy_green
            test_version $BLUE_SERVICE "Blue"
            test_version $GREEN_SERVICE "Green"
            check_deployment_status
            switch_traffic "green"
            log_success "Deployment completed successfully!"
            ;;
        deploy-blue)
            deploy_blue
            deploy_services
            ;;
        deploy-green)
            deploy_green
            ;;
        switch-to-blue)
            switch_traffic "blue"
            ;;
        switch-to-green)
            switch_traffic "green"
            ;;
        test)
            test_version $BLUE_SERVICE "Blue"
            test_version $GREEN_SERVICE "Green"
            ;;
        test-blue)
            test_version $BLUE_SERVICE "Blue"
            ;;
        test-green)
            test_version $GREEN_SERVICE "Green"
            ;;
        status)
            check_deployment_status
            ;;
        logs-blue)
            check_logs_for_errors $BLUE_DEPLOYMENT "blue"
            ;;
        logs-green)
            check_logs_for_errors $GREEN_DEPLOYMENT "green"
            ;;
        rollback)
            rollback
            ;;
        monitor-health)
            monitor_health
            ;;
        cleanup-blue)
            cleanup "blue"
            ;;
        cleanup-green)
            cleanup "green"
            ;;
        help|--help|-h)
            show_usage
            ;;
        *)
            log_error "Unknown command: $command"
            show_usage
            exit 1
            ;;
    esac
}

# Run main with all arguments
main "$@"