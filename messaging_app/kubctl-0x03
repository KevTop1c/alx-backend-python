#!/bin/bash

# kubctl-0x03: Rolling Update Script with Zero-Downtime Testing

trap 'cleanup; exit 130' INT    # CTRL+C
trap 'cleanup; exit 143' TERM   # SIGTERM
trap 'cleanup; exit 0' EXIT     # Normal exit

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Configuration
NAMESPACE="default"
DEPLOYMENT_FILE="blue_deployment.yaml"
DEPLOYMENT_NAME="django-messaging-app-blue"
SERVICE_NAME="django-messaging-service"
NEW_VERSION="2.0"
NEW_IMAGE="messaging_app:v2.0"
TEST_ENDPOINT="/admin/"
TEST_DURATION=120  # seconds to test during rollout
REQUEST_INTERVAL=0.5  # seconds between requests

# Counters
TOTAL_REQUESTS=0
SUCCESSFUL_REQUESTS=0
FAILED_REQUESTS=0
DOWNTIME_DETECTED=false

# Functions
log_header() {
    echo -e "\n${CYAN}================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}================================${NC}\n"
}
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_test() { echo -e "${MAGENTA}[TEST]$1${NC}"; }

# Function to check prerequisites
check_prerequisites() {
    log_header "Checking Prerequisites"
    
    # Check if kubectl is installed
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed"
        exit 1
    fi
    log_success "kubectl is available"
    
    # Check if curl is installed
    if ! command -v curl &> /dev/null; then
        log_error "curl is not installed"
        exit 1
    fi
    log_success "curl is available"
    
    # Check if deployment file exists
    if [ ! -f "$DEPLOYMENT_FILE" ]; then
        log_error "$DEPLOYMENT_FILE not found"
        exit 1
    fi
    log_success "Deployment file found: $DEPLOYMENT_FILE"
    
    # Check if deployment exists
    if ! kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE &> /dev/null; then
        log_error "Deployment $DEPLOYMENT_NAME not found"
        exit 1
    fi
    log_success "Deployment exists: $DEPLOYMENT_NAME"
    
    # Check if new image exists in Minikube
    log_info "Checking if new image exists in cluster..."
    if minikube image ls 2>/dev/null | grep -q "messaging_app.*v2.0"; then
        log_success "Image $NEW_IMAGE exists in Minikube"
    else
        log_warning "Image $NEW_IMAGE not found in Minikube"
        log_info "Attempting to load image..."
        
        # Check if image exists locally
        if docker images | grep -q "messaging_app.*v2.0"; then
            minikube image load messaging_app:v2.0
            log_success "Image loaded into Minikube"
        else
            log_warning "Creating v2.0 image from latest..."
            docker tag messaging_app:latest messaging_app:v2.0
            minikube image load messaging_app:v2.0
            log_success "Image created and loaded"
        fi
    fi
}

# Function to show current state
show_current_state() {
    log_header "Current Deployment State"
    
    echo -e "${CYAN}Deployment Status:${NC}"
    kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE
    
    echo -e "\n${CYAN}Current Pods:${NC}"
    kubectl get pods -l app=django-messaging,version=blue -n $NAMESPACE
    
    echo -e "\n${CYAN}Current Image:${NC}"
    kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}'
    echo -e "\n"
}

# Function to update deployment file
update_deployment_file() {
    log_header "Step 1: Updating Deployment File"
    
    log_info "Updating image to $NEW_IMAGE in $DEPLOYMENT_FILE..."
    
    # Backup original file
    cp $DEPLOYMENT_FILE "${DEPLOYMENT_FILE}.backup"
    log_success "Backup created: ${DEPLOYMENT_FILE}.backup"
    
    # Update image in deployment file
    sed -i.tmp "s|image: messaging_app:.*|image: $NEW_IMAGE|g" $DEPLOYMENT_FILE
    rm -f "${DEPLOYMENT_FILE}.tmp"
    
    # Verify the change
    if grep -q "$NEW_IMAGE" $DEPLOYMENT_FILE; then
        log_success "Deployment file updated with image: $NEW_IMAGE"
    else
        log_error "Failed to update deployment file"
        exit 1
    fi
    
    # Show the change
    log_info "Updated image line:"
    grep "image: messaging_app" $DEPLOYMENT_FILE | head -1
}

# Function to apply deployment and trigger rolling update
apply_rolling_update() {
    log_header "Step 2: Applying Rolling Update"
    
    log_info "Applying updated deployment..."
    kubectl apply -f $DEPLOYMENT_FILE
    
    log_success "Rolling update triggered!"
    
    # Show rollout strategy
    echo -e "\n${CYAN}Rollout Strategy:${NC}"
    kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.spec.strategy}' | jq '.'
    
    echo ""
}

# Function to setup port forwarding
setup_port_forward() {
    log_info "Setting up port forwarding for testing..."
    
    # Kill any existing port-forward
    pkill -f "kubectl port-forward.*$SERVICE_NAME" 2>/dev/null || true
    sleep 2
    
    # Start port forward in background
    kubectl port-forward service/$SERVICE_NAME 8080:80 -n $NAMESPACE &> /tmp/portforward.log &
    PORT_FORWARD_PID=$!
    
    # Wait for port forward to be ready
    sleep 3
    
    # Test if port forward is working
    if curl -s -o /dev/null -w "%{http_code}" http://localhost:8080$TEST_ENDPOINT 2>/dev/null | grep -q "200\|301\|302"; then
        log_success "Port forwarding established (PID: $PORT_FORWARD_PID)"
        return 0
    else
        log_error "Port forwarding failed"
        return 1
    fi
}

# Function to test for downtime during rollout
test_zero_downtime() {
    log_header "Step 3: Testing for Zero Downtime"
    
    log_info "Starting continuous requests for ${TEST_DURATION} seconds..."
    log_info "Testing endpoint: http://localhost:8080$TEST_ENDPOINT"
    echo ""
    
    local start_time=$(date +%s)
    local end_time=$((start_time + TEST_DURATION))
    local last_status=""

    # Initialize counters at the start of the function
    TOTAL_REQUESTS=0
    SUCCESSFUL_REQUESTS=0
    FAILED_REQUESTS=0
    DOWNTIME_DETECTED=false
    
    # Create test results file
    echo "timestamp,http_code,response_time,status" > /tmp/rollout_test_results.csv
    
    while [ $(date +%s) -lt $end_time ]; do
        TOTAL_REQUESTS=$((TOTAL_REQUESTS + 1))
        
        # Make request and capture response using Python for precise timing
        local start_ms=$(python -c 'import time; print(int(time.time() * 1000))')

        local http_code=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 2 \
            --max-time 5 \
            http://localhost:8080$TEST_ENDPOINT 2>/dev/null || echo "000")
        
        local end_ms=$(python -c 'import time; print(int(time.time() * 1000))')

        # Calculate duration in milliseconds
        local duration=$((end_ms - start_ms))
        
        # Check if request was successful
        if [[ "$http_code" =~ ^(200|301|302)$ ]]; then
            SUCCESSFUL_REQUESTS=$((SUCCESSFUL_REQUESTS + 1))
            
            if [ "$last_status" != "success" ]; then
                echo -e "${GREEN}✓${NC} Request #$TOTAL_REQUESTS: HTTP $http_code (${duration}ms) - OK"
                last_status="success"
            else
                echo -ne "\r${GREEN}✓${NC} Successful requests: $SUCCESSFUL_REQUESTS / $TOTAL_REQUESTS"
            fi
            
            echo "$(date +%s),$http_code,$duration,success" >> /tmp/rollout_test_results.csv
        else
            FAILED_REQUESTS=$((FAILED_REQUESTS + 1))
            DOWNTIME_DETECTED=true
            
            echo -e "\n${RED}✗${NC} Request #$TOTAL_REQUESTS: HTTP $http_code - FAILED"
            echo "$(date +%s),$http_code,$duration,failed" >> /tmp/rollout_test_results.csv
            
            last_status="failed"
        fi
        
        sleep $REQUEST_INTERVAL
    done

    echo "TOTAL_REQUESTS=$TOTAL_REQUESTS" > /tmp/test_results.env
    echo "SUCCESSFUL_REQUESTS=$SUCCESSFUL_REQUESTS" >> /tmp/test_results.env
    echo "FAILED_REQUESTS=$FAILED_REQUESTS" >> /tmp/test_results.env
    echo "DOWNTIME_DETECTED=$DOWNTIME_DETECTED" >> /tmp/test_results.env
    
    echo -e "\n"
}

# Function to monitor rollout status
monitor_rollout() {
    log_header "Step 4: Monitoring Rollout Progress"
    
    log_info "Watching rollout status..."
    echo ""
    
    # Start rollout status in background and capture output
    kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE &
    local rollout_pid=$!
    
    # Wait for rollout to complete
    wait $rollout_pid
    local rollout_status=$?
    
    echo ""
    
    if [ $rollout_status -eq 0 ]; then
        log_success "Rollout completed successfully!"
    else
        log_error "Rollout failed or timed out"
    fi
    
    return $rollout_status
}

# Function to verify rollout completion
verify_rollout() {
    log_header "Step 5: Verifying Rollout Completion"
    
    # Check deployment status
    echo -e "${CYAN}Deployment Status:${NC}"
    kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE
    
    echo -e "\n${CYAN}Current Pods:${NC}"
    kubectl get pods -l app=django-messaging,version=blue -n $NAMESPACE -o wide
    
    echo -e "\n${CYAN}New Image Version:${NC}"
    local current_image=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}')
    echo "$current_image"
    
    if [ "$current_image" == "$NEW_IMAGE" ]; then
        log_success "Image updated to $NEW_IMAGE"
    else
        log_error "Image update failed. Current: $current_image, Expected: $NEW_IMAGE"
        return 1
    fi
    
    # Check all pods are running
    echo -e "\n${CYAN}Pod Health:${NC}"
    local ready_pods=$(kubectl get pods -l app=django-messaging,version=blue -n $NAMESPACE --field-selector=status.phase=Running -o jsonpath='{.items[*].metadata.name}' | wc -w)
    local total_pods=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.spec.replicas}')
    
    echo "Ready Pods: $ready_pods / $total_pods"
    
    if [ "$ready_pods" -eq "$total_pods" ]; then
        log_success "All pods are running with new version"
    else
        log_warning "Not all pods are ready yet"
    fi
    
    # Check pod images
    echo -e "\n${CYAN}Pods Running New Image:${NC}"
    kubectl get pods -l app=django-messaging,version=blue -n $NAMESPACE -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[0].image}{"\n"}{end}'
}

# Function to show test results
show_test_results() {
    log_header "Zero-Downtime Test Results"
    
    local success_rate=0
    if [ $TOTAL_REQUESTS -gt 0 ]; then
        success_rate=$(awk "BEGIN {printf \"%.2f\", ($SUCCESSFUL_REQUESTS / $TOTAL_REQUESTS) * 100}")
    else
        log_warning "No requests were made during testing"
        success_rate="N/A"
    fi
    
    echo -e "${CYAN}Test Statistics:${NC}"
    echo "  Total Requests:      $TOTAL_REQUESTS"
    echo -e "  Successful Requests: ${GREEN}$SUCCESSFUL_REQUESTS${NC}"
    echo -e "  Failed Requests:     ${RED}$FAILED_REQUESTS${NC}"
    echo "  Success Rate:        ${success_rate}%"
    echo "  Test Duration:       ${TEST_DURATION} seconds"
    echo ""
    
    if [ $TOTAL_REQUESTS -eq 0 ]; then
        log_warning "No test data available - port forwarding may have failed"
        return
    fi

    if [ "$DOWNTIME_DETECTED" = true ]; then
        log_error "DOWNTIME DETECTED during rollout!"
        echo "  Some requests failed during the rolling update."
    else
        log_success "ZERO DOWNTIME ACHIEVED!"
        echo "  All requests succeeded during the rolling update."
    fi
    
    # Calculate statistics from results file
    if [ -f /tmp/rollout_test_results.csv ]; then
        echo -e "\n${CYAN}Response Time Statistics:${NC}"
        awk -F',' 'NR>1 && $4=="success" {sum+=$3; count++; if(min==""){min=max=$3}; if($3<min){min=$3}; if($3>max){max=$3}} END {if(count>0) printf "  Average: %.0fms\n  Min: %dms\n  Max: %dms\n", sum/count, min, max}' /tmp/rollout_test_results.csv
    else
        echo -e "\n${YELLOW}No response time data available${NC}"
    fi
}

# Function to show rollout history
show_rollout_history() {
    log_header "Rollout History"
    
    kubectl rollout history deployment/$DEPLOYMENT_NAME -n $NAMESPACE
}

# Function to cleanup
cleanup() {
    log_info "Cleaning up..."
    
    # Kill port forward and wait for it to terminate
    if [ ! -z "$PORT_FORWARD_PID" ] && kill -0 $PORT_FORWARD_PID 2>/dev/null; then
        log_info "Stopping port forwarding (PID: $PORT_FORWARD_PID)..."
        kill $PORT_FORWARD_PID 2>/dev/null
        # Wait a bit for the process to terminate gracefully
        sleep 2
        # Force kill if still running
        kill -9 $PORT_FORWARD_PID 2>/dev/null || true
        log_success "Port forwarding stopped"
    fi
    
    # Clean up any remaining port-forward processes
    local remaining_pids=$(pgrep -f "kubectl port-forward.*$SERVICE_NAME" 2>/dev/null || true)
    if [ ! -z "$remaining_pids" ]; then
        log_info "Cleaning up remaining port-forward processes..."
        kill $remaining_pids 2>/dev/null || true
        sleep 1
        kill -9 $remaining_pids 2>/dev/null || true
    fi
    
    # Clean up temp files
    rm -f /tmp/portforward.log /tmp/rollout_test_results.csv 2>/dev/null || true
}

# Function to show summary
show_summary() {
    log_header "Rolling Update Summary"
    
    # Calculate success_rate safely
    local success_rate="N/A"
    if [ $TOTAL_REQUESTS -gt 0 ]; then
        success_rate=$(awk "BEGIN {printf \"%.2f\", ($SUCCESSFUL_REQUESTS / $TOTAL_REQUESTS) * 100}")%
    fi

    echo -e "${GREEN}✓ Rolling Update Completed Successfully!${NC}"
    echo ""
    echo "Summary:"
    echo "  • Deployment: $DEPLOYMENT_NAME"
    echo "  • Old Image: messaging_app:latest"
    echo "  • New Image: $NEW_IMAGE"
    echo "  • Zero Downtime: $([ "$DOWNTIME_DETECTED" = false ] && echo "Yes ✓" || echo "No ✗")"
    echo "  • Success Rate: $success_rate"
    echo ""
    
    log_info "Next Steps:"
    echo "  • Monitor application: kubectl logs -f -l app=django-messaging,version=blue"
    echo "  • Check metrics: kubectl top pods -l app=django-messaging,version=blue"
    echo "  • View history: kubectl rollout history deployment/$DEPLOYMENT_NAME"
    echo "  • Rollback if needed: kubectl rollout undo deployment/$DEPLOYMENT_NAME"
    echo ""
    
    log_info "Test Results saved to: /tmp/rollout_test_results.csv"
}


# Main execution
main() {
    log_header "Rolling Update Script - Zero Downtime Deployment"
    
    # Step 0: Check prerequisites
    check_prerequisites
    
    # Show current state
    show_current_state
    
    # Step 1: Update deployment file
    update_deployment_file
    
    # Step 2: Setup port forwarding for testing
    if ! setup_port_forward; then
        log_error "Cannot setup port forwarding. Continuing without downtime testing..."
        SKIP_TESTING=true
    fi
    
    # Step 3 & 4: Apply update and test simultaneously
    log_header "Starting Rolling Update with Concurrent Testing"
    
    # Apply the rolling update
    apply_rolling_update
    
    # Start testing in background if port forward is working
    if [ "$SKIP_TESTING" != true ]; then
        log_info "Starting zero-downtime test in background..."
        test_zero_downtime &
        TEST_PID=$!
    else
        log_warning "Skipping zero-downtime testing due to port forwarding issues"
    fi
    
    # Monitor rollout status
    if ! monitor_rollout; then
        log_error "Rollout failed!"
        # Kill the test if it's still running
        if [ ! -z "$TEST_PID" ] && kill -0 $TEST_PID 2>/dev/null; then
            kill $TEST_PID 2>/dev/null
        fi
        exit 1
    fi
    
    # Wait for testing to complete
    if [ "$SKIP_TESTING" != true ] && [ ! -z "$TEST_PID" ]; then
        log_info "Waiting for zero-downtime test to complete (timeout: ${TEST_DURATION}s)..."
        
        # Wait for the test process with timeout
        local wait_time=0
        local max_wait=$((TEST_DURATION + 10))  # Add some buffer time
        
        while [ $wait_time -lt $max_wait ] && kill -0 $TEST_PID 2>/dev/null; do
            sleep 1
            ((wait_time++))
        done
        
        # If test is still running, kill it
        if kill -0 $TEST_PID 2>/dev/null; then
            log_warning "Test timed out - terminating..."
            kill $TEST_PID 2>/dev/null
            sleep 2
            kill -9 $TEST_PID 2>/dev/null || true
        else
            log_success "Zero-downtime test completed"
        fi
        
        # Ensure the process is reaped
        wait $TEST_PID 2>/dev/null || true
    fi

    if [ "$SKIP_TESTING" != true ] && [ ! -z "$TEST_PID" ]; then
    wait $TEST_PID 2>/dev/null || true
        # Load results from file
        if [ -f /tmp/test_results.env ]; then
            source /tmp/test_results.env
            rm -f /tmp/test_results.env
        fi
    fi
    
    # Step 5: Verify rollout
    verify_rollout
    
    # Show test results
    if [ "$SKIP_TESTING" != true ]; then
        show_test_results
    else
        log_warning "Zero-downtime testing was skipped - no results available"
    fi
    
    # Show rollout history
    show_rollout_history
    
    # Show summary
    show_summary
    
    log_success "Rolling update script completed!"
}

# Run main function
main